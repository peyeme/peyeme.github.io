<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sci-hub and google scholar research]]></title>
    <url>%2F2018%2F03%2F30%2Fsci_hub%2F</url>
    <content type="text"><![CDATA[谷歌学术镜像_Google学术搜索导航 sci-hub：一个神奇的免费下载文献的网站（使用技巧） 2017.12.16更新，抱歉下面三个网址用不了了。请用以下几个： http://www.sci-hub.tw/ http://www.sci-hub.tv/ http://www.sci-hub.la/ http://www.sci-hub.mm/ http://www.sci-hub.is/ http://www.sci-hub.ws/ http://www.sci-hub.hk/ http://www.sci-hub.cn/ http://www.sci-hub.sci-hub.tw/ http://www.sci-hub.sci-hub.mn/ http://www.sci-hub.sci-hub.hk/ http://www.sci-hub.org.cn/ 下面在网址上加http://sci-hub.cc的方法，目前可以改成加sci-hub.la，这样还是可以用的。 如果你使用www.sci-hub.org.cn这个网站，sci-hub和谷歌联合起来的搜索引擎，检索的结果点击全文下载，会出现意想不到的结果。 出现的结果会给出影响因子和中科院JCR分区，右侧几个按钮尝试一下，很多是可以一键下载的。 对于科研民工们，肯定很多人接触过sci-hub这个网站，一个很神奇的免费下载文献的网站。目前的网址是这三个。 http://www.sci-hub.cc/ http://www.sci-hub.bz/ http://www.sci-hub.ac/ 使用sci-hub有两种途径三个方法。第一种途径是上述三个网址进入hub这个网站，方法一是找到你要下载的文献的pdf下载页面网址，复制并粘贴到hub的搜索框中，即可下载；方法二是复制该文献的doi粘贴到hub搜索框中，即可下载；第二种途径是，不进入hub这个网站。使用Google学术或者百度学术等检索文献利器找到文献下载页面，在页面的网址里进行修改。修改方法是，该文献网址的主网站后面加上.http://sci-hub.cc .sci-hub.ac .sci-hub.bz 三个中任意一个。然后回车，你会发现，没有权限的文献马上就会出来pdf界面变成可以下载。 例如下面这个例子: Lake Qinghai, China: closed-basin like levels and the oxygen isotope record for ostracoda since the latest Pleistocene这个网址，这篇论文是需要purchase的。但是在.com后面加上.sci-hub.cc(Science, health and medical journals, full text articles and books..sci-hub.cc/science/article/pii/003101829190041O)立刻就变成了可下载状态。 欢迎大家围观专栏中的这一篇文章【文献检索】火狐和谷歌浏览器里的sci-hub插件 谷歌学术镜像_Google学术搜索导航http://ac.scmor.com/]]></content>
      <categories>
        <category>学习资源</category>
      </categories>
      <tags>
        <tag>Sci-hub</tag>
        <tag>google scholar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[引入 栈stack: 数学题,当推导不下去时,通常退一步去考虑其他可能性;一摞碗,可以把新的摞上去,而取得时候,总是取最后放上去的碗. 队列queue:银行排队办业务,叫号. 定义栈stack: Last In First Out(LIFO)关系的结构队列queue: First In First Out(FIFO)关系的结构 栈的应用栈是算法里最常用的辅助结构,基本用途基于两个方面: 作为辅助存储结构,临时保存信息,供后面操作中使用 栈具有LIFO特性,利用这一特性可以保证特定的存取关系 简单应用 括号匹配问题 考虑三种括号 :圆括号,方括号,花括号 开,闭应该相互对应 括号可能嵌套 HOWTO: 顺序扫描字符 跳过无关的字符(非括号字符) 遇到开括号,将其压入栈 遇到闭括号是弹出当时的栈顶元素与之匹配 如果匹配成功则继续,不成功则以失败结束]]></content>
      <categories>
        <category>数据结构与算法--Pyhton语言描述</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>stack</tag>
        <tag>队列</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python PEP代码形式]]></title>
    <url>%2F2018%2F03%2F24%2FPython%20PEP%E4%BB%A3%E7%A0%81%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[翻完一两遍《从问题到程序–用python学编程和计算》，才发现有些最基本的原则必须遵守。 空格问题 运算符前后应该加空格,逗号之后应该加空格,但逗号和冒号之间不加空格; 函数名与随后的参数表的括号之间不加空格; 每层代码之间统一退格4个空格,不用制表符Tab; 换行和空行 一行不要太长,过长时应当换行(必要时使用续行符); 在函数定义和类定义之间,在逻辑功能上互相有区分的大段代码之间加入空行,使代码的不同重要片段跟容易识别 注释尽可能写为独立的注释行]]></content>
      <categories>
        <category>从问题到程序--用Python学编程和计算</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PEP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配]]></title>
    <url>%2F2018%2F03%2F24%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[字符串匹配,也称子串匹配问题,是对字符串对象最重要的操作之一.这个操作本身很重要,同时也是许多其他字符操作的基础.Wiki上有专门的相关问题讨论 应用 文本中查找 Email服务器垃圾过滤 Google等网络搜索系统的基础就是在互联网的网页中查找与各种检索需求匹配的网页 各种防病毒软件检索表征病毒的片段,也是串匹配 生物DNA匹配 匹配算法朴素匹配算法两个字符t、p,在t中查找pt为目标串p为模式串 无回溯串匹配算法（ＫＭＰ算法） 问题分析不回溯:如果匹配中用模式串第i+1个字符匹配失败,那么直接将模式串前移k个位置(0&lt;k&lt;i),而不是仅仅只前移一个位置.所以关键是确定K.当匹配失败时,KMP算法会把模式串前移进行再次匹配,原本似乎应该根据目标串t中之前匹配的一段字符串来决定模式串的位置,实际上,因为之前匹配的一段字符串在t和p中是相同的,而且肯定是p中前i个字符串.那么确定k的问题只需要分析模式串p就可以了.将p切片成为从下表0开始的长度为1到m==len(p)的m个不同的字符串,对应于p于t匹配时分别有前1到前m个匹配的情况(m个匹配意味着完全匹配,但还是需要向前移动,t中可能有多个匹配). 构造移动表由于通常模式串p长度远远小于目标串长度,所以这样做会大大降低计算复杂度. 考虑构造一个移动pnext,len(pnext)==m. 实际看p的不同长度的切片中,首尾相同的字符的数量e.g. 123456789101112131415161718192021222324252627282930313233343536373839404142title p不同长度切片尾首相同字符长度分析section 长度为1实际无意义 切片0 :a1, 2018-01-01, 1d 切片0移动 :2018-01-01, 1d 完全重合实际无意义,后徐跳过直接从前移1开始分析 : 2018-01-01, 1dsection 切片长度为2 切片 :2018-01-01, 2d 切片前移1 :2018-01-02, 2d **重合1个**取k为1 :2018-01-02, 1d 切片 :2018-01-01, 2d 切片前移2 :2018-01-02, 2d 完全错位,无意义,后续略 :2018-01-02, 1dsection 切片长度为3 切片 :2018-01-01, 3d 切片前移1 :2018-01-02, 3d 若**重合2个**,取k为2,否则继续前移一位 :2018-01-02, 2d 切片 :2018-01-01, 3d 切片前移2 :2018-01-03, 3d 重合1个,取k为1:2018-01-03, 1dsection 切片长度为4 切片 :2018-01-01, 4d 切片前移1 :2018-01-02, 4d 若**重合3个**,取k为3,否则继续前移一位 :2018-01-02, 3d 切片 :2018-01-01, 4d 切片前移2 :2018-01-03, 4d 若**重合2个**,取k为2,否则继续前移一位 :2018-01-03, 2d 切片 :2018-01-01, 4d 切片前移3 :2018-01-03, 4d 若**重合1个**,直接取k为1,否则为0 :2018-01-03, 2dsection 切片长度为5 切片 :2018-01-01, 5d 切片前移1 :2018-01-02, 5d **重合4个** :2018-01-02, 4d 切片 :2018-01-01, 5d 切片前移2 :2018-01-03, 5d 重合3个 :2018-01-03, 3d 切片 :2018-01-01, 5d 切片前移3 :2018-01-04, 5d **重合2个** :2018-01-04, 2d 切片 :2018-01-01, 5d 切片前移4 :2018-01-05, 5d **重合1个** :2018-01-05, 1d - 当确定首尾相同的字符长度后,就可以用**切片的长度**减去**k**,即得到前移的量. - 切片的长度初始值是用p与t进行匹配,看有前多少(i)个字符相同,切片的长度为多少(i) - **每次移动在进行匹配,更新切片长度;根据切片长度,确定k值;得到位移量i-k** 图片插入也可以用&lt;img&gt;&lt;img src=&quot;https://peyeme.github.io/images/KMP%E6%94%B9%E8%BF%9B.jpg&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;改进的KMP算法&quot; align=center /&gt; 注意这里图片的链接https://peyeme.github.io/images/KMP%E6%94%B9%E8%BF%9B.jpg 而不是https://github.com/peyeme/peyeme.github.io/blob/master/images/KMP%E6%94%B9%E8%BF%9B.jpg 出现-1时,是因为匹配0个,需要向前移动1位,那么赋予一个特殊值-1,表示任何情况下只移动一位为什么pnext要从前一位开始?算的是匹配了几位,当然有一位都没匹配的情况,所以从前一位开始,因为p[0]实际上是第一位,也是匹配了一位pnext[0]默认是-1那么pnext1的值怎么确定:不管怎么取,第一个值总会是相等的,但是却给它赋值为0(默认pnext前两个值为-1,0) 在这个例子中,第一个元素是a,pnext1是0 但是,在后面(i&gt;1)位置出现a时,却赋值1`def gen_pnext(p): “””生成正对p中各位置i的下一位置检查表*,用于KMP算法,(原始版)””” i, k, m = 0, -1, len(p) pnext = [-1] m while i &lt; m-1: # 生成下一个pnext元素 if k == -1 or p[i] = p[k] : 若果特殊值-1,直接前移一位;如果当前值匹配,那么给pnext赋值,并且前移一位(加1) pnext[i+1] = k+1 # 因为pnext是从p的前一位开始的,pnext[-1]默认为-1,p[0]对应的是pnext1 # 实际上pnext[1]也是默认为0的,所以这个循环可已从pnext[2],也即p[i=1]开始 i, k = i+1, k+1 # 因此书上将这里合并为i, k = i+1, k+1 # pnext[i] = k # 结果是一致的 else: k = pnext[k] # 退到更短的pnext元素 # **书上的算法实现非常不直观,要不自己写一个好了** return pnext ` 我的思路是切片,把p切成从0,1…,len(p)-1不同长度的字符串如第一步:p[0:1]与p相比较,看有几个匹配,当然这里第一个因为是对其的,肯定是1个 # 因为Python默认是左闭右开,所以这实际上是p的第一个元素第二步:p[1:2]]]></content>
      <categories>
        <category>数据结构与算法--Pyhton语言描述</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样阅读Python手册]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%80%8E%E6%A0%B7%E9%98%85%E8%AF%BBPython%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[PSF的Python语言系统附带的语言文档: Python教程(The Pyhton Tutorial):介绍Python语言的基本情况和Python编程基础,包括对语言中各结构的简短说明和小段的样例代码. Python语言手册(The Python Language Reference):以比较严格(比较形式化的)方式说明Python语言的各方面情况,包括结构的形式和语义等 Python标准库(The Python Standard library):分门别类地介绍了Python系统携带的各种标准模块,模块里提供的功能和简单的使用方法. 各版本的新特征 安装与使用 如何为Python安装其他程序模块 用Python编程时解决的一些常见的具体技术(Python HOWTO) 对一些常见问题的回答(Python Frenqency Asked Question)]]></content>
      <categories>
        <category>从问题到程序--用Python学编程和计算</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog原文件同步]]></title>
    <url>%2F2018%2F03%2F21%2Fblog%E5%8E%9F%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[解决blog文件云备份同步问题 使用onedrive 使用Github建立分支 使用onedrive引用如何像用Dropbox那样用OneDrive备份你的本地文件 优点:onedrive与Windows系统深度整合,文件有改动,立刻就会启动同步 方法:使用mklink /j命令 首先Windows其实是支持软链的，不光是快捷方式。需要使用到的命令为mklink。 MKLINK的用法如下： MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件 符号链接。 /H 创建硬链接，而不是符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径 (相对或绝对)。这里你需要的具体命令应该是： mklink /J [LOCAL FOLDER PATH FOR ONEDRIVE] [LOCAL FOLDER PATH TO BE SYNCED] 举例如下：我的文档的默认位置是C:\Users\Peye\Documents\blog ； 那么如果我需要在OneDrive里同步我的文档，该怎么做呢？ mklink /J C:\Users\Peye\OneDrive\blogSync C:\Users\Peye\Documents\blog 这时你的OneDrive里就会出现一个叫blogSync的文件夹，里面的内容则和原来的blog文件夹一模一样。 ================================== 稍微讲解下MKLINK各种参数（/D /H /J）的区别。 /D 是指生成一个软链文件。是SYMLINKD 类型。Windows称之为“符号链接” /J 则是指生成一个JUNCTION类型的软链文件。Windows称之为“目录联接”。 注意这两个用词上的差别：链接和联接。链接严格来说是个名词，也就是说这是一个类似于.lnk文件的东西，记载了“源文件的实际位置”。而联接则不同，在抽象概念上相当于这两个文件夹是对等的。在IO的过程中，程序需要“理解”SYMLINKD类型的软链（尽管微软的资料称symlinkd对应用程序是透明的……可是onedrive就可以识别出来），而JUNCTION类型的软链则是直接由操作系统负责解释，对应用程序来说是透明的，OneDrive它“看不到这是个软链”，在它访问软链的时候操作系统会自动帮它转至真正的文件所在处。所以在这里我们选用了mklink /J 。 /H 就是创建一个硬链接。 自己做的一个对比图如下： 对加星部分，以及“要特殊讨论的情况”做下解释。 为什么源文件被删除后，硬链接还可以正常访问文件呢？因为硬链接相当于是一个别名。你所删除的“源文件”其实也只是删除了一个别名而已。这就好比我既叫韩学森又叫可可苏玛；假如哪天我觉得可可苏玛这个ID不好听了，我可以把它删掉。但我本人不会因此消失。。。而需要特殊讨论的是什么呢？ 前面说过，Junction Point和SymbolLink对于应用程序来说，应该都是“透明”的。这也就导致有些应用程序没法分辨你是要删除“软连接”，还是要删除“源文件”。在WindowsVista之后，Explorer和rmdir都可以正确识别了；有些第三方应用仍然不可以。 ==================================== 推荐同步的文件夹：文档、图片、桌面。 使用mklink命令的时候记得使用“命令提示符（管理员）”。 #Github分支法 作者：CrazyMilk链接：https://www.zhihu.com/question/21193762/answer/79109280来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 还有问题,待续]]></content>
      <categories>
        <category>blog原文件同步</category>
      </categories>
      <tags>
        <tag>onedrivenedrive</tag>
        <tag>Github分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Blog之路]]></title>
    <url>%2F2018%2F03%2F19%2FGithub%20blog%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Github Blog之路搭建blog参考了@ryanluoxu的用-Hexo-和-GitHub-Pages-搭建博客@tanchao90用Hexo和GitHub Pages搭建个人博客@wordzzzz我的个人博客之旅：从jekyll到hexo当然&amp;官方hexo文档 心路历程 Github配置 Hexo配置 next配置 心路历程Github还是在校期间注册了,轻度使用过,因该是连门都没入.毕业后经历了十几年了,期间荒废了很多年,也断断续续学了一些东西.从2018年1月,在市图书馆(从遇见到第一次亲密接触错过了很多次机会，人说失去才知道珍惜，其实在得到才会更珍惜)借了一本《从问题到程序–用Python学编程和计算》，打开了我的Programming之路。这本书看了三个月,初学者是一本不可多得的好书.为了学习编程，决定开个博客，于是又得到了我的Github。也准备把这几年来学习所得都放上去. 这几年学的很杂. 毕业后7/8年都是以工作为主,奔着Radar engineer方向去了,说实话我是很热爱我的专业的,也用心去做,无奈流水无情终须离开. 2012年考研,在本科毕业7年后重新走进大学校园–西北工业大学.考研成功也给了自己信心,我还可以学习.三年经历开拓了眼界,入门了科研、骑行、户外、露营、游泳……我知道我的生活不会再枯燥了. 毕业后几年为静心学习书法 为和My baby girl交流,学绘画 为了心中的建筑梦,从基础的力学,到建筑设计,到艺术史 GithubCreate Repository name:peyeme.github.io 然后就开始求索一路,当然,一开始是jekyll,但是不会用bing,知乎(国内小白之路还是从这两个容易&amp;靠谱一点的开始)看到了hexo,学习 如何保存原始文件到github上作者：张钊链接：https://www.zhihu.com/question/21193762/answer/172097576来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 可以更新使用最新的 hexo-deployer-git 插件，因为没有发布到 npm 的原因，必须得从 github 安装npm install git+git@github.com:hexojs/hexo-deployer-git.git –save在项目根目录下的 _config.yml 里面就可以这样配置# _config.yaml deploy: - type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master - type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: src extend_dirs: / ignore_hidden: false ignore_pattern: public: . 这样，在每次写完博客的时候时候使用 hexo d 命令就能将所有其他文件发布到 src 分支换电脑的时候就能通过 git 重新下载下来整个项目，然后本地切换到远端的 src 分支git checkout origin/src 就能重新获得所有的源文件，就能重新 hexo d 发布对于每一个从 git 下载下来的项目或者主题，最好把每个的 .git 文件夹删掉，否则得通过 submodule 的方式来安装。hexohexo文档 https://hexo.io/zh-cn/docs/index.html Hexo目录结构说明 _config.yml 网站的配置信息 package.json 应用程序的信息。EJS, Stylus和Markdown renderer已默认安装 scaffolds 模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件 source 资源文件夹是存放用户资源的地方 _drafts 草稿箱，可以将不想发布的文章放在该目录下面，比如我将自己的写作模板文件放在这里 _posts 该目录下的文件会被生成和发布 themes 主题文件夹。Hexo 会根据主题来生成静态页面 public 执行generate命令后生成public文件夹，并解析Markdown和HTML文件到该目录 常用命令 以下是操作Hexo书写、生成、部署博客常用的几个命令，后面会有详细介绍： hexo init [folder] hexo version hexo list hexo new [layout] hexo publish [layout] hexo generate hexo clean hexo server hexo deploy Example 创建草稿，写作，本地预览 hexo new draft my_blog hexo server –draft 写作完成之后，发布草稿，生成静态博客，并部署到 Github Pages hexo –config custom.yml publish draft my_blog hexo clean 正常情况不需要执行该命令 hexo –config custom.yml generate hexo –config custom.yml deploy 遇到的问题fsevent是mac osx系统的，在win或者Linux下使用了,所以会有警告，忽略即可。1234567$ npm install hexo-deployer-git --savenpm WARN deprecated swig@1.4.2: This package is no longer maintainednpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-deployer-git@0.3.1added 116 packages and updated 1 package in 18.176s next设置更多常见问题见next网站http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95next更多问题https://github.com/iissnan/hexo-theme-next/issues?page=2&amp;q=is%3Aissue+is%3Aopen 如何修改已发布的博客的名字(哈哈,很二很小白的问题)title: {{ title }} #改这里的名字就行了,刚开始是从别的地方拷贝过来的.MD,没有title,结果显示未命名,怎么都改不了,呵呵了 date: {{ date }} update: {{ date }} tags: type: &quot;categories&quot; categories: top: #设置置顶,设置数值，数值越大文章越靠前 #sticky: #100 next文档中的置顶方法 #copyright: true #新增,开启 如何设置「阅读全文」？在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐在文章的 front-matter 中添加 description，并提供文章摘录自动形成摘要，在 主题配置文件 中添加： auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定 建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。 置顶解决Hexo置顶问题,参考解决Hexo置顶问题 $ npm uninstall hexo-generator-index --save $ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。 Github: https://github.com/netcan/hexo-generator-index-pin-top 本地搜索在你站点的根目录下 $ npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 search: path: search.xml field: post format: html limit: 10000 打开 themes/next/_config.yml ,搜索关键字 local_search ,设置为 true： # Local search # Dependencies: https://github.com/flashlab/hexo-generator-search local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 创建菜单项对应文件目录,以分类为例在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ： $ cd your-hexo-site $ hexo new page categories 编辑刚新建的页面,设置分类 --- title: 分类 date: 2014-12-22 12:39:04 categories: Testing #分类名 type: &quot;categories&quot; --- 版权设置参见自定义文章底部版权声明 设置新建文章自动开启项--- title: {{ title }} date: {{ date }} tags: type: &quot;categories&quot; categories: copyright: true #新增,开启 --- 文章顶部显示更新时间打开主题配置文件 _config.yml ,搜索关键字 updated_at 设置为 true ： # Post meta display settings post_meta: item_text: true created_at: true updated_at: ture categories: true 编辑文章,增加关键字updated（next可以根据文章改变时间自动更改） --- layout: layout title: 关于 date: 2017-08-18 15:41:18 updated: 2017-09-05 20:18:54 #手动添加更新时间 ---]]></content>
      <categories>
        <category>置顶</category>
      </categories>
      <tags>
        <tag>Github Blog</tag>
      </tags>
  </entry>
</search>
